---
title: "Cross Summary functions and functional clustering"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(ggplot2)
library(dplyr)
library(spatstat)
library(tidyverse)
library(purrr)
library(fda)
library(forcats)
library(readxl)
library(FADPclust)
```

```{r}
dati <- readRDS("dataset/patients_region1.rds")
```

2. Split dataset into a list of dataframes (one per patient)

```{r}
patients_list <- split(dati, dati$patients)
```

full dataset ppp
```{r}
ppp_pats <- readRDS("dataset/ppp_obj_clean_data.rds")
```


# Analisi Esplorativa

```{r}
hist_list <- map(names(ppp_pats), function(id) {
  data.frame(
    patient = id,
    mark = marks(ppp_pats[[id]])
  )
})

# Combine into one data.frame
all_hist <- bind_rows(hist_list)

# Plot histogram of marks with facets by patient
ggplot(all_hist, aes(x = mark, fill = mark)) +
  geom_bar() +
  facet_wrap(~ patient, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Cell type", y = "Count", title = "Histogram of Marks per Patient")
```

Controlliamo il "tumor boundary"
```{r}
imap(ppp_pats, \(pat, name){
  temp_df <- data.frame(
    x = pat$x,
    y = pat$y,
    mark = marks(pat)
  ) |> 
    filter(mark %in% c("Bulk tumor", "Tumor boundary"))
  
  # Quick plot
  p <- ggplot(temp_df, aes(x=x, y=y, color=mark)) +
    geom_point(alpha = 0.7) +
    coord_fixed() +
    labs(title = paste0("Patient ", name, ": bulk tumor and tumor boundary")) +
    theme_minimal()
  p
})  
```

## Put togheter bulk and boundary tumor

```{r}
ppp_pats <- map(patients_list, function(pat) {
  # Get unique cell types present in this patient
  pat <- pat[!is.na(pat$cell_type),]
  present_types <- unique(pat$cell_type)
  
  # Determine if at least one of the target types is present
  to_merge <- intersect(present_types, c("Bulk tumor", "Tumor boundary"))
  do_collapse <- length(to_merge) > 0
  
  if(do_collapse) {
    # Collapse any present into "Tumor" (even if one missing)
    celltypes <- fct_collapse(as.factor(pat$cell_type),
                              Tumor = intersect(levels(as.factor(pat$cell_type)), c("Bulk tumor", "Tumor boundary"))) %>%
      fct_drop()  # Drop unused levels
  } else {
    celltypes <- as.factor(pat$cell_type)
  }
  ppp_creation(pat, celltypes)
})
```




Controlliamo di nuovo come sono le numerosita dei 2 tipi cellulari interessati
```{r}
hist_list <- map(names(ppp_pats), function(id) {
  data.frame(
    patient = id,
    mark = marks(ppp_pats[[id]])
  )
})

# Combine into one data.frame
all_hist <- bind_rows(hist_list)

# Plot histogram of marks with facets by patient
ggplot(all_hist, aes(x = mark, fill = mark)) +
  geom_bar() +
  facet_wrap(~ patient, scales = "free_y") +
  scale_y_log10() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 7), # Make cell type text smaller
    axis.text.y = element_text(size = 7),                        # Make y-axis numbers smaller
    strip.text = element_text(size = 8)                          # (Optional) Make facet label smaller
  ) +
  labs(x = "Cell type", y = "Count", title = "Histogram of Marks per Patient - log10 scale")
```

Controllo il numero di Tumor cell e Immune-infiltrated stroma cell per ogni paziente
```{r}
iwalk(ppp_pats, \(pat, name) {
  print(paste0("Patient ", name, " has: ", npoints(pat[pat$marks == "Tumor"]), " cell of Tumor type and ", 
               npoints(pat[pat$marks == "Immune-infiltrated stroma"]), " cell of Immune-infiltrated stroma type"))
 })
```

Rimuovo il paziente 10 e il paziente 19 perche ha poche cellule espresse tra quelle di interesse. 

```{r}
ppp_pats <- ppp_pats[!(names(ppp_pats) %in% c('10', '19'))]
```


# Lcross function

Vogliamo studiare la relazione che intercorre tra i pazienti, rispetto alle funzioni Lcross, prendendo il processo di punto generato dalle cellule cancerose e confrontato con gli altri tipi cellulari. 

Ho gia' ripulito da pazienti con pochi punti o problematici quindi non servono check sui tipi o sul numero

```{r}
Lcross_list <- map(ppp_pats, function(pat){
  Lcross(pat, "Tumor", "Immune-infiltrated stroma", correction = "best")
})
```

```{r}
walk(Lcross_list, plot)
```

## Aggiungo intervalli di confidenza

Uso gli intervalli pointwise e non globali perche produce NaN con quest'ultimo, non chiaro perche'

```{r}
Lcross_loh <- map(ppp_pats, \(pat){ 
  Lloh <- lohboot(pat, Lcross, block = TRUE, conf = 0.95, nsim = 500, nx = 4, type = 7, global = FALSE)
})
```

```{r}
walk(Lcross_loh, \(x) {plot(x, .-r~r)})
```

### Global envelopes

```{r}
Lcross_env <- map(ppp_pats, \(pat){ 
  envelope(pat, Lcross, nsim=100, rank=1, global=TRUE, 
           i = "Tumor", j = "Immune-infiltrated stroma", 
           correction = "best", rmax = 150)
})
```

```{r}
iwalk(Lcross_env, \(x, name) {
    plot(x, .-r~r, legend = F)
    title(paste0("processo di punto del paziente ", name))
  })
```


## Smoothed functions

Calcolo delle funzioni Lcross lisciate tramite B-spline 
```{r}
Lfun_list <- Lcross_smooth(ppp_pats, centrata = T)
```

```{r}
plot(Lfun_list$fd)
lines(c(0,350), c(0,0), col = "gold", lwd = 2)
```

### Functional PCA

Calcoliamo fpca per 4 componenti e mostriamo il risultato sulla rotazione VARIMAX

```{r}
fpca <- pca.fd(Lfun_list$fd, nharm = 4, Lfun_list$fdPar)
rownames(fpca$scores) <- names(Lcross_list) # "nome" dei pazienti (numero del paziente)

fpcaVarmx <- varmx.pca.fd(fpca)
```

### fPCA plot ruotate per VARIMAX

The plots below show the mean function and the effects of adding (+) and subtracting (âˆ’) a
suitable multiple of the first (resp. second) principal component function.

```{r}
plot.pca.fd(fpcaVarmx, cex.main=0.9)
```

## Clustering

Applichiamo due metodi di clustering sugli scores delle prime 4 componenti.
Clustering gerarchico con metodo Ward e kmeans

```{r}
set.seed(123)
fpca_km <- kmeans(fpca$scores[,c(1,4)], 5)
fpca_hc <- hclust(dist(fpca$scores[,c(1,4)]), method = "ward.D2")
memb <- cutree(fpca_hc, k = 5)
```

Grafico del dendogramma per il clustering gerarchico, scegliamo di dividere in 5 cluster.

```{r}
dhc <- as.dendrogram(fpca_hc)
plot(dhc, cex = 0.1, horiz = T)
ggdendrogram(dhc, rotate = TRUE, size = 2)
table(kmean = fpca_km$cluster)
table(ward.d2 = memb)
```

```{r}
plot(fpca$scores[,1], fpca$scores[,2], col = fpca_km$cluster, pch = 3, main = "kmeans")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
plot(fpca$scores[,1], fpca$scores[,2], col = memb, pch = 3, main = "Ward.d2")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
```

# Informazioni sui pazienti 
```{r}

pat_data <- read_excel("dataset/CRC_TMAs_patient_annotations.xlsx", n_max = 35)
head(pat_data)
colnames(pat_data)
table(pat_data$Group) # il gruppo al momento non mi interessa, tanto ogni paziente ne ha uno, puo aver senso vedere se i raggruppamenti sono rispettati e riconosciuti dal clustering
```
Aggiunfo info clustering al dataset dei pazienti
```{r}
cluster_df <- tibble::tibble(
  Patient = as.integer(names(fpca_km$cluster)),
  Cluster = as.integer(fpca_km$cluster)
)

# Join by Patient column
pat_data <- pat_data |> 
  left_join(cluster_df, by = "Patient")
```

```{r}
table(pat_data$Cluster, pat_data$Group)
table(pat_data$Cluster, pat_data$Sex)
table(pat_data$Group, pat_data$Sex)

table(pat_data$Full_Histology, pat_data$Cluster)
table(pat_data$Simple_Tumor_Location, pat_data$Cluster)
table(pat_data$Full_Tumor_Location, pat_data$Cluster)
```


# PCF cross

```{r}
pcfcross_list <- map(ppp_pats, function(pat){
  pcfcross(pat, "Tumor", "Immune-infiltrated stroma", correction = "best", divisor = "d", kernel = "rectangular", bw = "ucv")
})
```


```{r}
walk(pcfcross_list, plot)
```

```{r}
pcffun_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
                               divisor = "d", kernel = "epanechnikov", bw = "bcv")
```

```{r}
plot(pcffun_list$fd)
```

### Functional PCA

Calcoliamo fpca per 4 componenti e mostriamo il risultato sulla rotazione VARIMAX

```{r}
fpca <- pca.fd(pcffun_list$fd, nharm = 4, pcffun_list$fdPar)
rownames(fpca$scores) <- names(Lcross_list) # "nome" dei pazienti (numero del paziente)

fpcaVarmx <- varmx.pca.fd(fpca)
```

### fPCA plot ruotate per VARIMAX

```{r}
plot.pca.fd(fpcaVarmx, cex.main=0.9)
```

## Clustering

Applichiamo due metodi di clustering sugli scores delle prime 4 componenti.
Clustering gerarchico con metodo Ward e kmeans

```{r}
set.seed(123)
fpca_km <- kmeans(fpca$scores[,c(1,4)], 5)
fpca_hc <- hclust(dist(fpca$scores[,c(1,4)]), method = "ward.D2")
memb <- cutree(fpca_hc, k = 5)
```

Grafico del dendogramma per il clustering gerarchico, scegliamo di dividere in 5 cluster.

```{r}
table(kmean = fpca_km$cluster)
table(ward.d2 = memb)
```

```{r}
plot(fpca$scores[,1], fpca$scores[,2], col = fpca_km$cluster, pch = 3, main = "kmeans")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
plot(fpca$scores[,1], fpca$scores[,2], col = memb, pch = 3, main = "Ward.d2")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
```

Aggiunfo info clustering al dataset dei pazienti
```{r}
cluster_df <- tibble::tibble(
  Patient = as.integer(names(fpca_km$cluster)),
  Cluster_pcf = as.integer(fpca_km$cluster)
)

# Join by Patient column
pat_data <- pat_data |> 
  left_join(cluster_df, by = "Patient")
```

```{r}
table(pat_data$Cluster_pcf, pat_data$Group)
table(pat_data$Cluster_pcf, pat_data$Sex)
table(pat_data$Group, pat_data$Sex)

table(pat_data$Full_Histology, pat_data$Cluster_pcf)
table(pat_data$Simple_Tumor_Location, pat_data$Cluster_pcf)
table(pat_data$Full_Tumor_Location, pat_data$Cluster_pcf)
```

# density based functional clustering

```{r}
fadp_out <- FADPclust(Lfun_list$fd)
fadp_out
```

# Distance based function

## Fcross

Empty space function

```{r}
Gcross_list <- funcross_smooth(ppp_pats, fun = Gcross)
```

```{r}
Gcross_list <- map(ppp_pats, \(pat){Gest(pat, correction = "best", rmax = 100)})
walk(Gcross_list, plot)
```

