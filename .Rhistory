knitr::opts_chunk$set(echo = FALSE)
library(spatstat)
library(ggplot2)
library(arrow)
library(fda)
install.packages("fda")
library(spatstat)
library(ggplot2)
library(arrow)
library(fda)
library(tidyverse)
library(msigdbr)
library(knitr)
library(ggdendro)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(ggplot2)
library(dplyr)
library(spatstat)
dat = read_csv("dataset/CRC_clusters_neighborhoods_markers.csv")
pat1 <- dat[dat$patients == 1,]
pat1 |> ggplot(aes(`X:X`, `Y:Y`, color = `neighborhood name`)) + geom_point()
dat_ranked <- dat |>
group_by(patients) |>
mutate(region_rank = dense_rank(Region)) |>
ungroup()
# 1 pixel == 0.18 micron
dat_ranked$x_px <- dat_ranked$`X:X`
dat_ranked$y_px <- dat_ranked$`Y:Y`
dat_ranked$cell_type = dat_ranked$`neighborhood name`
# 2. Extract the first dataset (Rank 1 regions)
dat_gr1 <- dat_ranked %>%
filter(region_rank == 1) %>%
select(-region_rank) # remove the helper column
# 3. Extract the second dataset (Rank 2 regions)
dat_gr2 <- dat_ranked %>%
filter(region_rank == 2) %>%
select(-region_rank) # remove the helper column
saveRDS(dat_gr1, file = "dataset/patients_region1.rds")
saveRDS(dat_gr2, file = "dataset/patients_region2.rds")
#saveRDS(dat_gr1, file = "dataset/patients_region1.rds")
#saveRDS(dat_gr2, file = "dataset/patients_region2.rds")
rm(list=ls())
dati <- readRDS("dataset/patients_region1.rds")
table(dati$patients)
knitr::opts_chunk$set(echo = TRUE)
ppp_creation <- function(data, marks_name) {
# Define Window
wnd_px <- owin(c(min(data$x_px), max(data$x_px)),
c(min(data$y_px), max(data$y_px)))
# Create ppp object
my_ppp <- ppp(x = data$x_px,
y = data$y_px,
window = wnd_px,
marks = factor(marks_name)) # factors are usually better for marks
unitname(my_ppp) <- c("pixel","pixels")
# Handle duplicates (optional, removes points at exact same location)
my_ppp <- unique.ppp(my_ppp)
return(my_ppp)
}
patients_list <- split(dati, dati$patients)
ppp_pats <- map(patients_list, function(pat) {
# Note: Ensure 'cell_type' column exists in your data.
# If it is named 'ClusterID' or something else, update it here.
ppp_creation(pat, pat$cell_type)
})
ppp_pats
ppp_pats$`1`
ppp_pats$`1`$marks
library(purrr)
ppp_pats$`1`
Lest(ppp_pats$`1`)
ppp_pats <- map(patients_list, function(pat) {
# Note: Ensure 'cell_type' column exists in your data.
# If it is named 'ClusterID' or something else, update it here.
celltypes <- as.factor(pat$cell_type)
ppp_creation(pat, celltypes)
})
# Check the result
# ppp_pats is now a list of ppp objects, named by patient ID
print(names(ppp_pats))
?Lest
Lest_list <- map(ppp_pats, function(pat){
Lest(pat, correction = "best")
})
Lest_list$`1`
plot_data <- imap_dfr(Lest_list, function(regions_list, patient_id) {
imap_dfr(regions_list, function(fv_data, region_name) {
# Extract data and calculate L(r) - r
as.data.frame(fv_data) %>%
select(r, iso) %>%
mutate(
PatientID = as.character(patient_id),
Region = region_name,
# The specific transformation you requested:
L_centered = iso - r
)
})
})
lapply(Lest_list, plot)
lapply(Lest_list, plot)
lapply(Lest_list, plot)
lapply(Lest_list, plot, .-r ~ r)
lapply(Lest_list, plot, .-r ~ r)
ppp_pats$`1`
split(ppp_pats$`1`)
Lest_list <- map(ppp_pats, function(pat){
map(split(pat), function(ppp_mark){
Lest(ppp_mark, correction = "best")})
})
Lest_list$`1`
plot_data <- imap_dfr(Lest_list, function(regions_list, patient_id) {
imap_dfr(regions_list, function(fv_data, region_name) {
# Extract data and calculate L(r) - r
as.data.frame(fv_data) %>%
select(r, iso) %>%
mutate(
PatientID = as.character(patient_id),
Region = region_name,
# The specific transformation you requested:
L_centered = iso - r
)
})
})
# Create a list of plots
patient_plots <- plot_data %>%
group_by(PatientID) %>%
group_map(function(data, keys) {
ggplot(data, aes(x = r, y = L_centered, color = Region)) +
# Add reference line at 0 (Theoretical Random distribution)
geom_hline(yintercept = 0, linetype = "dashed", color = "black", size = 0.5) +
# Plot the curves
geom_line(size = 0.8, na.rm = TRUE) +
scale_color_brewer(palette = "Set1") +
theme_bw() +
labs(
title = paste("Patient:", keys$PatientID),
subtitle = "Centered L-function",
y = "L(r) - r",
x = "Radius (r)",
color = "Region"
)
}, .keep = TRUE) # .keep=TRUE ensures grouping variable is retained if needed
# Create a list of plots
patient_plots <- plot_data %>%
group_by(PatientID) %>%
group_map(function(data, keys) {
ggplot(data, aes(x = r, y = L_centered, color = Region)) +
# Add reference line at 0 (Theoretical Random distribution)
geom_hline(yintercept = 0, linetype = "dashed", color = "black", size = 0.5) +
# Plot the curves
geom_line(linewidth = 0.8, na.rm = TRUE) +
scale_color_brewer(palette = "Set1") +
theme_bw() +
labs(
title = paste("Patient:", keys$PatientID),
subtitle = "Centered L-function",
y = "L(r) - r",
x = "Radius (r)",
color = "Region"
)
}, .keep = TRUE) # .keep=TRUE ensures grouping variable is retained if needed
patient_plots
?pcf
?bw.optim
pcf_list <- map(ppp_pats, function(pat){
map(split(pat), function(ppp_mark){
pcf(ppp_mark,
correction = "best",
kernel = "rectangular",
divisor = "a",
zerocor = "JonesFoster",
bw = bw.diggle
)})
})
?clarkevans.test
ppp_pats
ppp_pats$`1`
clarkevans.test(ppp_pats$`1`, alternative = "regular")
prova <- clarkevans.test(ppp_pats$`1`, alternative = "regular")
prova
str(prova)
prova$p.value
divisor_h <- function(ppp_obj, alpha = 0.05){
p_value <- clarkevans.test(ppp_obj, correction = "Donnelly", alternative = "regular")$p.value
if (p_value > alpha)
return("a")
return("d")
}
ppp_pats
pcf_fun <- possibly(function(ppp_mark) {
pcf(ppp_mark,
correction = "best",
kernel = "rectangular",
divisor = "a",
zerocor = "JonesFoster",
bw = bw.diggle)
}, otherwise = NULL)
pcf_fun <- possibly(function(ppp_mark, divisor = NULL) {
pcf(ppp_mark,
correction = "best",
kernel = "rectangular",
divisor = divisor, # it can be a chr or a fun that return the right chr value
zerocor = "JonesFoster",
bw = bw.diggle)
}, otherwise = NULL)
divisor_h <- function(ppp_obj, alpha = 0.05){
p_value <- clarkevans.test(ppp_obj, correction = "Donnelly", alternative = "regular")$p.value
if (p_value > alpha)
return("a")
return("d")
}
pcf_list <- map(ppp_pats, function(pat){
map(split(pat), \(x) {pcf_fun(x, divisor = "a")})
})
