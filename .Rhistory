library(dplyr)
library(spatstat)
library(tidyverse)
library(purrr)
library(fda)
library(forcats)
library(readxl)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(ggplot2)
library(dplyr)
library(spatstat)
library(purrr)
library(fda)
ppp_creation <- function(data, marks_name) {
# Define Window
wnd_px <- owin(c(min(data$x_px), max(data$x_px)),
c(min(data$y_px), max(data$y_px)))
# Create ppp object
my_ppp <- ppp(x = data$x_px,
y = data$y_px,
window = wnd_px,
marks = factor(marks_name)) # factors are usually better for marks
unitname(my_ppp) <- c("pixel","pixels")
# Handle duplicates (optional, removes points at exact same location)
my_ppp <- unique.ppp(my_ppp)
# Remove NA
my_ppp <- my_ppp[!is.na(marks(my_ppp))]
return(my_ppp)
}
divisor_h <- function(ppp_obj, alpha = 0.05){
p_value <- clarkevans.test(ppp_obj, correction = "Donnelly", alternative = "regular")$p.value
if (p_value > alpha)
return("a")
return("d")
}
Lest_smooth <- function(ppp_obj, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
{
# 1. Calculate raw L-functions (Common for both)
Lfun <- lapply(split(ppp_obj), Lest, correction = "best", rmax = rmax)
r <- Lfun[[1]]$r
mat_Lfun <- sapply(Lfun, function(x) x$iso)
# 2. Apply centering ONLY if requested
if(centrata == TRUE){
mat_Lfun <- sweep(mat_Lfun, MARGIN = 1, STATS = r, FUN = "-")
}
# --- FIX: Remove columns with NAs/Inf (Applied to BOTH cases) ---
bad_columns <- apply(mat_Lfun, 2, function(x) any(is.na(x) | is.infinite(x)))
if(any(bad_columns)){
n_removed <- sum(bad_columns)
warning(paste("Removed", n_removed, "functions containing NAs/Inf before smoothing."))
# Subset matrix to keep only good columns
mat_Lfun <- mat_Lfun[, !bad_columns]
}
# ----------------------------------------------------------------
# 3. Create Basis and Smooth
K <- length(r) + M - 2
genbasis <- create.bspline.basis(range(r), K, M, r)
genfdPar <- fdPar(genbasis, genLfun.fd, lambda = 1e-11)
genfdSmooth <- smooth.basis(r, mat_Lfun, genfdPar)
Lfun.fd <- genfdSmooth$fd
# 4. Set Names
fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
fdnames <- list(fdn_dist,
"Gene" = colnames(mat_Lfun), # Crucial: use names of surviving columns
"Funzione L")
Lfun.fd$fdnames <- fdnames
return(list(fd = Lfun.fd, fdPar = genfdPar,
basis = genbasis, mat = mat_Lfun, r = r))
}
# OLD VERSION
# Lest_smooth <- function(ppp_obj, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
# {
#   if(centrata == F){
#     Lfun <- lapply(split(ppp_obj), Lest, correction = "best", rmax = rmax)
#     mat_Lfun <- sapply(Lfun, function(x) x$iso)
#     r <- Lfun[[1]]$r
#     K <- length(r) + M - 2
#     genbasis <- create.bspline.basis(range(r), K, M, r)
#     genfdPar <- fdPar(genbasis, genLfun.fd, lambda = 1e-11)
#     genfdSmooth <- smooth.basis(r, mat_Lfun, genfdPar)
#     Lfun.fd <- genfdSmooth$fd
#     fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
#     fdnames <- list(fdn_dist,
#                     "Gene" = levels(ppp_obj$marks),
#                     "Funzione L")
#     Lfun.fd$fdnames <- fdnames
#   } else {
#     Lfun <- lapply(split(ppp_obj), Lest, correction = "best", rmax = rmax)
#     r <- Lfun[[1]]$r
#     # centriamo Lfun
#     mat_Lfun <- sapply(Lfun, function(x) x$iso) |>
#       sweep(MARGIN = 1, STATS = r, FUN = "-")
#     K <- length(r) + M - 2
#     genbasis <- create.bspline.basis(range(r), K, M, r)
#     genfdPar <- fdPar(genbasis, genLfun.fd, lambda = 1e-11)
#     genfdSmooth <- smooth.basis(r, mat_Lfun, genfdPar)
#     Lfun.fd <- genfdSmooth$fd
#     fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
#     fdnames <- list(fdn_dist,
#                     "Gene" = levels(ppp_obj$marks),
#                     "Funzione L")
#     Lfun.fd$fdnames <- fdnames
#   }
#   return(list(fd = Lfun.fd, fdPar = genfdPar,
#                 basis = genbasis, mat = mat_Lfun, r = r))
# }
Lcross_smooth <- function(ppp_obj, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
{
Lcross_list <- map(ppp_obj, function(pat){
Lcross(pat, "Tumor", "Immune-infiltrated stroma", correction = "best")
})
# 1. Calculate raw L-functions (Common for both)
r <- Lcross_list[[1]]$r
mat_Lfun <- sapply(Lcross_list, function(x) x$iso)
# 2. Apply centering ONLY if requested
if(centrata == TRUE){
mat_Lfun <- sweep(mat_Lfun, MARGIN = 1, STATS = r, FUN = "-")
}
# 3. Create Basis and Smooth
K <- length(r) + M - 2
genbasis <- create.bspline.basis(range(r), K, M, r)
genfdPar <- fdPar(genbasis, genLfun.fd, lambda = 1e-11)
genfdSmooth <- smooth.basis(r, mat_Lfun, genfdPar)
Lfun.fd <- genfdSmooth$fd
# 4. Set Names
fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
fdnames <- list(fdn_dist,
"Gene" = colnames(mat_Lfun), # Crucial: use names of surviving columns
"Funzione L")
Lfun.fd$fdnames <- fdnames
return(list(fd = Lfun.fd, fdPar = genfdPar,
basis = genbasis, mat = mat_Lfun, r = r))
}
Lest_plot <- function(Lest_estimate){
plot_data <- imap_dfr(Lest_estimate, function(regions_list, patient_id) {
imap_dfr(regions_list, function(fv_data, region_name) {
# Extract data and calculate L(r) - r
as.data.frame(fv_data) |>
select(r, iso) |>
mutate(
PatientID = as.character(patient_id),
Region = region_name,
# The specific transformation you requested:
L_centered = iso - r
)
})
})
# Create a list of plots
patient_plots <- plot_data |>
group_by(PatientID) |>
group_map(function(data, keys) {
ggplot(data, aes(x = r, y = L_centered, color = Region)) +
# Add reference line at 0 (Theoretical Random distribution)
geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.5) +
# Plot the curves
geom_line(linewidth = 0.8, na.rm = TRUE) +
scale_color_brewer(palette = "Set1") +
theme_bw() +
labs(
title = paste("Patient:", keys$PatientID),
subtitle = "Centered L-function",
y = "L(r) - r",
x = "Radius (r)",
color = "Cell Type"
)
}, .keep = TRUE) # .keep=TRUE ensures grouping variable is retained if needed
return(patient_plots)
}
pcf_plot <- function(pcf_estimate){
plot_data <- imap_dfr(pcf_estimate, function(regions_list, patient_id) {
imap_dfr(regions_list, function(fv_data, region_name) {
if (is.null(fv_data) || is.character(fv_data) || !inherits(fv_data, "fv")) {
return(NULL)
}
df <- as.data.frame(fv_data)
df |>
select(r, iso) |>
mutate(
PatientID = as.character(patient_id),
Region = region_name,
pcf = iso
)
})
})
# Create a list of plots
patient_plots <- plot_data |>
group_by(PatientID) |>
group_map(function(data, keys) {
ggplot(data, aes(x = r, y = pcf, color = Region)) +
geom_hline(yintercept = 1, linetype = "dashed", color = "black", linewidth = 0.5) +
geom_line(linewidth = 0.8, na.rm = TRUE) +
scale_color_brewer(palette = "Set1") +
theme_bw() +
labs(
title = paste("Patient:", keys$PatientID),
subtitle = "Pair Correlation Function",
y = "g(r)",
x = "Radius (r)",
color = "Cell Type"
)
}, .keep = TRUE)
return(patient_plots)
}
dati <- readRDS("dataset/patients_region1.rds")
patients_list <- split(dati, dati$patients)
ppp_pats <- map(patients_list, function(pat) {
# Get unique cell types present in this patient
pat <- pat[!is.na(pat$cell_type),]
present_types <- unique(pat$cell_type)
# Determine if at least one of the target types is present
to_merge <- intersect(present_types, c("Bulk tumor", "Tumor boundary"))
do_collapse <- length(to_merge) > 0
if(do_collapse) {
# Collapse any present into "Tumor" (even if one missing)
celltypes <- fct_collapse(as.factor(pat$cell_type),
Tumor = intersect(levels(as.factor(pat$cell_type)), c("Bulk tumor", "Tumor boundary"))) %>%
fct_drop()  # Drop unused levels
} else {
celltypes <- as.factor(pat$cell_type)
}
ppp_creation(pat, celltypes)
})
hist_list <- map(names(ppp_pats), function(id) {
data.frame(
patient = id,
mark = marks(ppp_pats[[id]])
)
})
# Combine into one data.frame
all_hist <- bind_rows(hist_list)
# Plot histogram of marks with facets by patient
ggplot(all_hist, aes(x = mark, fill = mark)) +
geom_bar() +
facet_wrap(~ patient, scales = "free_y") +
scale_y_log10() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 7), # Make cell type text smaller
axis.text.y = element_text(size = 7),                        # Make y-axis numbers smaller
strip.text = element_text(size = 8)                          # (Optional) Make facet label smaller
) +
labs(x = "Cell type", y = "Count", title = "Histogram of Marks per Patient - log10 scale")
ppp_pats <- ppp_pats[!(names(ppp_pats) %in% c('10', '19'))]
Lcross_list <- map(ppp_pats, function(pat){
Lcross(pat, "Tumor", "Immune-infiltrated stroma", correction = "best")
})
Lcross_loh <- map(ppp_pats, \(pat){
Lloh <- lohboot(pat, Lcross, block = TRUE, conf = 0.95, nsim = 500, nx = 4, type = 7, global = FALSE)
})
?envelope
Lcross_env <- map(ppp_pats, \(pat){
envelope(pat, Lcross, nsim=100, rank=1, global=TRUE)
})
walk(Lcross_env, \(x) {plot(x, .-r~r)})
?Lcross
Lcross_env <- map(ppp_pats, \(pat){
envelope(pat, Lcross, nsim=100, rank=1, global=TRUE, i = "Tumore", j = "Immune-infiltrated stroma", correction = "best")
})
Lcross_env <- map(ppp_pats, \(pat){
envelope(pat, Lcross, nsim=100, rank=1, global=TRUE, i = "Tumor", j = "Immune-infiltrated stroma", correction = "best")
})
walk(Lcross_env, \(x) {plot(x, .-r~r)})
Lfun_list <- Lcross_smooth(ppp_pats, centrata = T)
plot(Lfun_list$fd)
lines(c(0,350), c(0,0), col = "gold", lwd = 2)
fpca <- pca.fd(Lfun_list$fd, nharm = 4, Lfun_list$fdPar)
rownames(fpca$scores) <- names(Lcross_list) # "nome" dei pazienti (numero del paziente)
fpcaVarmx <- varmx.pca.fd(fpca)
plot.pca.fd(fpcaVarmx, cex.main=0.9)
set.seed(123)
fpca_km <- kmeans(fpca$scores[,c(1,4)], 5)
fpca_hc <- hclust(dist(fpca$scores[,c(1,4)]), method = "ward.D2")
memb <- cutree(fpca_hc, k = 5)
table(kmean = fpca_km$cluster)
table(ward.d2 = memb)
plot(fpca$scores[,1], fpca$scores[,2], col = fpca_km$cluster, pch = 3, main = "kmeans")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
plot(fpca$scores[,1], fpca$scores[,2], col = memb, pch = 3, main = "Ward.d2")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
pat_data <- read_excel("dataset/CRC_TMAs_patient_annotations.xlsx", n_max = 35)
head(pat_data)
colnames(pat_data)
table(pat_data$Group) # il gruppo al momento non mi interessa, tanto ogni paziente ne ha uno, puo aver senso vedere se i raggruppamenti sono rispettati e riconosciuti dal clustering
cluster_df <- tibble::tibble(
Patient = as.integer(names(fpca_km$cluster)),
Cluster = as.integer(fpca_km$cluster)
)
# Join by Patient column
pat_data <- pat_data |>
left_join(cluster_df, by = "Patient")
table(pat_data$Cluster, pat_data$Group)
table(pat_data$Cluster, pat_data$Sex)
table(pat_data$Group, pat_data$Sex)
table(pat_data$Full_Histology, pat_data$Cluster)
table(pat_data$Simple_Tumor_Location, pat_data$Cluster)
table(pat_data$Full_Tumor_Location, pat_data$Cluster)
pcfcross_list <- map(ppp_pats, function(pat){
pcfcross(pat, "Tumor", "Immune-infiltrated stroma", correction = "best", divisor = "d", kernel = "rectangular", bw = "ucv")
})
walk(pcfcross_list, plot)
?pcfcross
pcfcross()
class(pcfcross())
class(pcfcross
)
funcross_smooth <- function(ppp_obj, fun, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
{
funcross_list <- map(ppp_obj, function(pat){
fun(pat, "Tumor", "Immune-infiltrated stroma", correction = "best")
})
# 1. Calculate raw L-functions (Common for both)
r <- funcross_list[[1]]$r
mat_fun <- sapply(funcross_list, function(x) x$iso)
# 2. Apply centering ONLY if requested
if(centrata == TRUE){
mat_fun <- sweep(mat_fun, MARGIN = 1, STATS = r, FUN = "-")
}
# 3. Create Basis and Smooth
K <- length(r) + M - 2
genbasis <- create.bspline.basis(range(r), K, M, r)
genfdPar <- fdPar(genbasis, genLfun.fd, lambda = 1e-11)
genfdSmooth <- smooth.basis(r, mat_fun, genfdPar)
Genfun.fd <- genfdSmooth$fd
# 4. Set Names
fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
fdnames <- list(fdn_dist,
"Gene" = colnames(mat_fun), # Crucial: use names of surviving columns
"Funzione")
Lfun.fd$fdnames <- fdnames
return(list(fd = Genfun.fd, fdPar = genfdPar,
basis = genbasis, mat = mat_fun, r = r))
}
pcfcross_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
?fdPar
funcross_smooth <- function(ppp_obj, fun, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
{
funcross_list <- map(ppp_obj, function(pat){
fun(pat, "Tumor", "Immune-infiltrated stroma", correction = "best")
})
# 1. Calculate raw L-functions (Common for both)
r <- funcross_list[[1]]$r
mat_fun <- sapply(funcross_list, function(x) x$iso)
# 2. Apply centering ONLY if requested
if(centrata == TRUE){
mat_fun <- sweep(mat_fun, MARGIN = 1, STATS = r, FUN = "-")
}
# 3. Create Basis and Smooth
K <- length(r) + M - 2
genbasis <- create.bspline.basis(range(r), K, M, r)
genfdPar <- fdPar(genbasis, genGenfun.fd, lambda = 1e-11)
genfdSmooth <- smooth.basis(r, mat_fun, genfdPar)
Genfun.fd <- genfdSmooth$fd
# 4. Set Names
fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
fdnames <- list(fdn_dist,
"Gene" = colnames(mat_fun), # Crucial: use names of surviving columns
"Funzione")
Genfun.fd$fdnames <- fdnames
return(list(fd = Genfun.fd, fdPar = genfdPar,
basis = genbasis, mat = mat_fun, r = r))
}
pcfcross_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
funcross_smooth <- function(ppp_obj, fun, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
{
funcross_list <- map(ppp_obj, function(pat){
fun(pat, "Tumor", "Immune-infiltrated stroma", correction = "best")
})
# 1. Calculate raw L-functions (Common for both)
r <- funcross_list[[1]]$r
mat_fun <- sapply(funcross_list, function(x) x$iso)
# 2. Apply centering ONLY if requested
if(centrata == TRUE){
mat_fun <- sweep(mat_fun, MARGIN = 1, STATS = r, FUN = "-")
}
# 3. Create Basis and Smooth
K <- length(r) + M - 2
genbasis <- create.bspline.basis(range(r), K, M, r)
genfdPar <- fdPar(genbasis, genLfun.fd, lambda = 1e-11)
genfdSmooth <- smooth.basis(r, mat_fun, genfdPar)
Genfun.fd <- genfdSmooth$fd
# 4. Set Names
fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
fdnames <- list(fdn_dist,
"Gene" = colnames(mat_fun), # Crucial: use names of surviving columns
"Funzione")
Genfun.fd$fdnames <- fdnames
return(list(fd = Genfun.fd, fdPar = genfdPar,
basis = genbasis, mat = mat_fun, r = r))
}
pcfcross_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
pcffun_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F)
plot(pcffun_list$fd)
funcross_smooth <- function(ppp_obj, fun, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F, ...)
{
funcross_list <- map(ppp_obj, function(pat){
fun(pat, "Tumor", "Immune-infiltrated stroma", correction = "best", ...)
})
# 1. Calculate raw L-functions (Common for both)
r <- funcross_list[[1]]$r
mat_fun <- sapply(funcross_list, function(x) x$iso)
# 2. Apply centering ONLY if requested
if(centrata == TRUE){
mat_fun <- sweep(mat_fun, MARGIN = 1, STATS = r, FUN = "-")
}
# 3. Create Basis and Smooth
K <- length(r) + M - 2
genbasis <- create.bspline.basis(range(r), K, M, r)
genfdPar <- fdPar(genbasis, genLfun.fd, lambda = 1e-11)
genfdSmooth <- smooth.basis(r, mat_fun, genfdPar)
Genfun.fd <- genfdSmooth$fd
# 4. Set Names
fdn_dist <- paste("Distanza (da 0 a", rmax, "micron)")
fdnames <- list(fdn_dist,
"Gene" = colnames(mat_fun), # Crucial: use names of surviving columns
"Funzione")
Genfun.fd$fdnames <- fdnames
return(list(fd = Genfun.fd, fdPar = genfdPar,
basis = genbasis, mat = mat_fun, r = r))
}
pcffun_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "rectangular", bw = "ucv")
plot(pcffun_list$fd)
lines(c(0,350), c(0,0), col = "gold", lwd = 2)
plot(pcffun_list$fd)
?bw.ucv
pcffun_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "rectangular", bw = "bcv")
plot(pcffun_list$fd)
pcffun_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "epanechnikov", bw = "bcv")
plot(pcffun_list$fd)
pcffun_epa <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "epanechnikov", bw = "bcv")
pcffun_ret <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "rectangular", bw = "bcv")
pcffun_gau <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "gaussian", bw = "bcv")
plot(pcffun_epa$fd)
plot(pcffun_ret$fd)
plot(pcffun_gau$fd)
pcffun_epa <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "epanechnikov", bw = "bcv")
pcffun_ret <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "epanechnikov", bw = "ucv")
pcffun_gau <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "gaussian", bw = "bcv")
plot(pcffun_epa$fd)
plot(pcffun_ret$fd)
plot(pcffun_gau$fd)
pcffun_epa <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "epanechnikov", bw = "bcv")
pcffun_list <- funcross_smooth(ppp_pats, fun = pcfcross, rmax = NULL, M = 6, genLfun.fd = 4, centrata = F,
divisor = "d", kernel = "epanechnikov", bw = "bcv")
plot(pcffun_list$fd)
fpca <- pca.fd(pcffun_list$fd, nharm = 4, pcffun_list$fdPar)
fpca <- pca.fd(pcffun_list$fd, nharm = 4, pcffun_list$fdPar)
rownames(fpca$scores) <- names(pcffun_list) # "nome" dei pazienti (numero del paziente)
fpca
fpca$scores
names(pcffun_list)
names(Lcross_list)
rownames(fpca$scores) <- names(Lcross_list) # "nome" dei pazienti (numero del paziente)
fpcaVarmx <- varmx.pca.fd(fpca)
plot.pca.fd(fpcaVarmx, cex.main=0.9)
set.seed(123)
fpca_km <- kmeans(fpca$scores[,c(1,4)], 5)
fpca_hc <- hclust(dist(fpca$scores[,c(1,4)]), method = "ward.D2")
memb <- cutree(fpca_hc, k = 5)
dhc <- as.dendrogram(fpca_hc)
plot(dhc, cex = 0.1, horiz = T)
ggdendrogram(dhc, rotate = TRUE, size = 2)
table(kmean = fpca_km$cluster)
table(ward.d2 = memb)
plot(fpca$scores[,1], fpca$scores[,2], col = fpca_km$cluster, pch = 3, main = "kmeans")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
plot(fpca$scores[,1], fpca$scores[,2], col = memb, pch = 3, main = "Ward.d2")
abline(v = 0, lty = "dashed", col = "grey")
abline(h = 0, lty = "dashed", col = "grey")
cluster_df <- tibble::tibble(
Patient = as.integer(names(fpca_km$cluster)),
Cluster_pcf = as.integer(fpca_km$cluster)
)
# Join by Patient column
pat_data <- pat_data |>
left_join(cluster_df, by = "Patient")
table(pat_data$Full_Histology, pat_data$Cluster_pcf)
table(pat_data$Simple_Tumor_Location, pat_data$Cluster_pcf)
table(pat_data$Full_Tumor_Location, pat_data$Cluster_pcf)
table(pat_data$Cluster_pcf, pat_data$Group)
table(pat_data$Cluster_pcf, pat_data$Sex)
table(pat_data$Group, pat_data$Sex)
install.packages("FADPclust")
knitr::opts_chunk$set(echo = TRUE)
library(FADPclust)
?FADPclust
fadp_out <- FADPclust(pcffun_list$fd, cluster = 2:10, method = "FADP1", proportion = NULL,
f.cut = 0.15, pve = 0.9, stats = "Avg.silhouette")
fadp_out <- FADPclust(pcffun_list$fd)
fadp_out
fadp_out <- FADPclust(pcffun_list$fd)
fadp_out <- FADPclust(pcffun_list)
fadp_out <- FADPclust(pcffun_list$fd)
fadp_out <- FADPclust(Lcross_list$fd)
Lfun_list <- Lcross_smooth(ppp_pats, centrata = T)
fadp_out <- FADPclust(Lfun_list$fd)
Lfun_list$fd
?fd
class(Lfun_list)
class(Lfun_list$fd)
